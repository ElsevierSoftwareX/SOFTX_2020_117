# Notes
# - CHECK substrate absorbtion. Comment and value don't agree.
# - Which of the 4 effects contribute to HR-RoC change and thermal lensing?
# - Is the expression correct given how the input powers are given?
# - Is it the path length or physical distance that should be used in the end to
#   model the new effective RoCs?



import numpy as np
import pykat
import matplotlib.pyplot as plt
import scipy.special as sp
import scipy.optimize as so
import pylab
from scipy.optimize import minimize

def createSurface(Rc,X,zOffset=None,isPlot=False):
    '''
    Creating surface.

    Inputs: Rc, X, Y, zOffset=0, x0=0, y0=0, xTilt=0, yTilt=0, isPlot=False
    Rc      - Radius of curvature, and center of sphere on z-axis in case zOffset=0. [m]
    X, Y    - Matrices of x,y-values generated by 'X,Y = numpy.meshgrid(xVec,yVec)'. [m]
    zOffset - Surface center offset from 0. Positive value gives the surface center
              positive z-coordinate. [self.scaling]
    x0,y0   - The center of the sphere in the xy-plane.
    x/yTilt - Tilt of x/y-axis [rad]. E.g. xTilt rotates around the y-axis.
    isPlot  - Plot or not [boolean]. Not recommended when used within optimization
              algorithm.

    Returns: Z
    Z       - Matrix of surface height values. [self.scaling]

    Based on Simtools function 'FT_create_sphere_for_map.m' by Charlotte Bond.
    '''

    if Rc == np.inf:
        Rc = 0

    # Adding offset
    if zOffset is None:
        Z = 0
    else:
        Z = zOffset

    # Adding spherical shape.
    if not Rc is None and Rc != 0:
        Z = Z + Rc - np.sign(Rc)*np.sqrt(Rc**2 - X**2)
    else:
        Z = Z*np.ones(len(X), dtype=float)

    if isPlot:
        import pylab
        plt.clf()
        fig = plt.figure()
        ax = fig.add_subplot(111)
        ax.plot(X,Z)
        plt.show(fig)
    return Z
    
def fit_circle(x, z, Rc0, w=None, zOff0=None, maxfev=2000):

    '''
    Fits circular surface to data. 

    Inputs: Rc0, w, zOff, isCenter
    x        - Array with distances away from the center.
    z        - Data to fit the circle to.
    Rc0      - Initial guess of the Radius of curvature. [m]
    w        - Gaussian weighting parameter. The distance from the center where the
               weigths have decreased by a factor of exp(-2) compared to the center.
               Should preferrably be equal to the beam radius at the mirror. [m]
    zOff0    - Initial guess of the z-offset. Generally unnecessary. [surfacemap.scaling]
    
    Returns: Rc, zOff
    Rc       - Radius of curvature of the sphere [m]
    zOff     - z-offset of the sphere [m]
    '''

    # z-value at centre of the data-grid. Serves as initial guess for deviation
    # from z=0, if no other first guess is given.
    if zOff0 is None:
        zOff0 = z[np.abs(x).argmin()]

    # Initial guesses of radius of curvature and z-offset. 
    p = [Rc0, zOff0]
    # Grids with X,Y and r2 values. X and Y crosses zero in the center
    # of the xy-plane.
    # Cost-function to minimize.
    def costFunc(p):
        Rc = p[0]
        zOff = p[1]
        Z = createSurface(Rc,x,zOff)
        if w is None:
            # Mean squared difference between map and the created sphere.
            res = np.sqrt( ((z - Z)**2).sum() )/len(z)
        else:
            # Weights centered around the center of the mirror xy-plane.
            weight = (2/(np.pi*w**2))*np.exp(-2*x**2/w**2)
            # Weighted mean squared difference between map and the created sphere.
            res = np.sqrt( ( weight*( (z - Z)**2 )).sum() )/weight.sum()
            return res

    # Using the simplex Nelder-Mead method. This is the same or very
    # similar to the method used in 'FT_remove_curvature_from_mirror_map.m',
    # but there are probably better methods to use.
    opts = {'xtol': 1.0e-5, 'ftol': 1.0e-9, 'maxiter': 10000, 'maxfev': maxfev, 'disp': False}
    out = minimize(costFunc, p, method='Nelder-Mead', options=opts)
    # print(out)
    print(out['message'])
    # print(out)
    print(' Iterations: {}'.format(out['nit']))
    print(' Function value: {:.2e}'.format(out['fun']))
    if not out['success']:
        msg = '  Warning: ' + out['message'].split('.')[0] + ' (nfev={:d}).'.format(out['nfev'])

    # Assigning values to the instance variables
    Rc = out['x'][0]
    zOffset = out['x'][1]
    
    return Rc, zOffset

def hellovinet(P_coat, P_sub_in, P_sub_out, HR_RoC, AR_RoC, **kwargs):
    """
    Computes the effective change in optical path length of a mirror due to thermal lensing
    and suface deformation effects on a mirror from the power and absorbtion coefficients.
    A spherical surface is fitted to the data, and the resulting change in RoC is extraced.
    Based on Hello & Vinet, J. Phys. France 51 (1990) 1267-1282. Function written by Valeria
    Sequino, translated from Matlab function by ?.
                    
                   Mirror 
                  AR     HR 
    P_sub_in      |      |
    ---------->   |      |
                  |      |
    P_sub_out     |      |   P_coat
    <----------   |      |  <----------  
                  |      |

    Inputs:
    -------
    P_coat         - Power on HR coating from vacuum side
    P_sub_in       - Power going into AR surface
    P_sub_out      - Power coming out of AR surface
    thickness      - Mirror thickness [m] (default 0.2 m)
    aCoat          - Coating power absorption (default 1.5 ppm)
    aSub           - Substrate power absorptio [1/cm] default (0.3ppm/cm)
    n              - Mirror index of refraction (default SiO2, 1.452).
    a              - Test mass radius [m] (default 0.175 m)
    w              - Gaussian spot size [m] (default 0.049 m)
    K              - Mirror thermal conductivity (default 1.380)
    T0             - Surrounding temperature [K] (default 295.0 K)
    emiss          - Mirror emissivity (default 0.89)
    alpha          - Mirror thermal expansion coefficient (default 0.54e-6)
    sigma          - Mirror Poisson's ratio (default 0.164)
    dndT           - Mirror index of refraction change with temperature (default 8.7 ppm)


    Returns:
    --------
    
    """ 

    # Default values
    #############################################

    

    
    # constants
    sigmab=5.67e-8 # Stephan-Boltzmann constant

    h=0.2          # test mass thickness
    aCoat=1.5e-6;  # coating absorption
    aSub=3.0e-5;   # substrate absorption 0.3ppm/cm
    n=1.452;       # SiO2 refraction index
    a=0.175;       # test mass radius
    w=0.049;       # IFO beam waist
    K=1.380        # SiO2 thermal conductivity
    T0=295.0       # room temperature
    emiss=0.89;    # SiO2 emissivity
    alpha=0.54e-6; # SiO2 thermal expansion coefficient
    sigma=0.164;   # SiO2 Poisson's ratio
    dndT=8.7e-6;   # self explanatory

    Pin=125;       # IFO input power
    RecG=37.5;     # recycling gain
    Finesse=443;   # F-P cavity finesse not used

    # Updating values from specified arguments
    for k, v in kwargs.items():
        if k == 'aCoat':
            aCoat = v
        elif k == 'thickness':
            h = v
        elif k == 'aSub':
            aSub = v
        elif k == 'n':
            n = v
        elif k == 'a':
            a = v
        elif k == 'w':
            w = v
        elif k == 'K':
            K = v
        elif k == 'T0':
            T0 = v
        elif k == 'emiss':
            emiss = v
        elif k == 'alpha':
            alpha = v
        elif k == 'sigma':
            sigma = v
        elif k == 'dndT':
            dndT = v

    # Total power going into the coating
    Pc = P_coat + P_sub_in

    # Total power going through the substrate
    Ps = P_sub_in + P_sub_out
    
    # Pc=RecG*Pin*Finesse/np.pi+Pin*RecG /2  #power on the coating
    # Ps=Pin*RecG/2  #power in the substrate

    chi=4*emiss*sigmab*T0**3*a/K #radiative heat losses

    def g(x):
        return x*sp.jv(1,x) - chi*sp.jv(0,x)

    # Initial root guesses of g(x)
    i = np.linspace(1,51,51)
    x0s = (i-1.0+1.0/4.0)*np.pi
        
    # Finding roots of g(x)
    zetha = np.zeros(len(x0s))
    for k,x0 in enumerate(x0s):
        out = so.fsolve(g, x0, xtol = 1e-8, full_output = True, maxfev = 1000)
        # Printing message if no root found.
        if out[2] != 1:
            print(out[3])
            print(x0)
        zetha[k] = float(out[0])


    gamma = h/(2.0*a)*zetha
    A = 1.0/(2.0*(zetha*np.sinh(gamma)+chi*np.cosh(gamma)))
    B = 1.0/(2.0*(zetha*np.cosh(gamma)+chi*np.sinh(gamma)))
    beta = 1.0/8.0*w**2/a**2*zetha**2
    p = 1.0/(np.pi*a**2)*zetha**2/((zetha**2+chi**2)*(sp.jv(0,zetha))**2)*np.exp(-beta)
    r = np.linspace(0,a,int(np.round(a/0.001))+1)
    z = np.linspace(-h/2, h/2, int(np.round(h/0.001))+1)

    ############### THIS IS NOT CORRECT MAYBE?

    oos = np.zeros([len(r), len(zetha)])
    ooc = np.zeros([len(r), len(zetha)])

    for i in range(len(r)):  
        for k in range(len(zetha)):
                oos[i,k] = p[k]/zetha[k]**2*(1-2*chi*A[k]/gamma[k]*np.sinh(gamma[k]))*sp.jv(0,zetha[k]*r[i]/a)
                ooc[i,k] = p[k]/zetha[k]*2*A[k]*np.sinh(gamma[k])*sp.jv(0,zetha[k]*r[i]/a)

    # Thermo-optic effect due to coating absorption
    OPLc=Pc*aCoat*a**2/K*dndT*np.sum(ooc,1)
    # Thermo-optic effect due to substrate absorption
    OPLs=Ps*aSub*h*a**2/K*dndT*np.sum(oos,1)
    # Thermo-elastic effect due to coating absorption
    OPLtec=alpha*(sigma+1)*(n-1)*Pc*aCoat*a**2/K*np.sum(ooc,1)
    # Thermo-elastic effect due to substrate absorption
    OPLtes=alpha*(sigma+1)*(n-1)*Ps*aSub*h*a**2/K*np.sum(oos,1)
    # Total thermal effect
    OPLTM=OPLc+OPLs+OPLtec+OPLtes    

    # In Finesse we want to separate this into two effects:
    # 1. Effective HR-surface deformation seen by the intra cavity field.
    # 2. Effective thermal lens seen by beams passing through the substrate.
    # Question: How do we achieve this?
    # Guess: I think only the thermo-elastic effect due to coating absorption
    #        should affect 1. The other three contributions gets added as a
    #        thermal lens.
    
    OPL_coat = OPLtec
    OPL_sub = OPLs + OPLtes + OPLc

    # Rc, zOffset = fit_circle(r, OPLTM, -1000, w=0.049, zOff0=None, maxfev=2000)
    return r, OPL_coat, OPL_sub






